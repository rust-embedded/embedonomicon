<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A main interface - The Embedonomicon</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-embedded/embedonomicon" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-main-interface"><a class="header" href="#a-main-interface">A <code>main</code> interface</a></h1>
<p>We have a minimal working program now, but we need to package it in a way that the end user can build
safe programs on top of it. In this section, we'll implement a <code>main</code> interface like the one standard
Rust programs use.</p>
<p>First, we'll convert our binary crate into a library crate:</p>
<pre><code class="language-console">$ mv src/main.rs src/lib.rs
</code></pre>
<p>And then rename it to <code>rt</code> which stands for "runtime".</p>
<pre><code class="language-console">$ sed -i s/app/rt/ Cargo.toml

$ head -n4 Cargo.toml
</code></pre>
<pre><code class="language-toml">[package]
edition = "2024"
name = "rt" # &lt;-
version = "0.1.0"
</code></pre>
<p>The first change is to have the reset handler call an external <code>main</code> function:</p>
<pre><code class="language-console">$ head -n13 src/lib.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">#![no_std]

use core::panic::PanicInfo;

// CHANGED!
#[unsafe(no_mangle)]
pub unsafe extern "C" fn Reset() -&gt; ! {
    unsafe extern "Rust" {
        safe fn main() -&gt; !;
    }

    main()
}</code></pre></pre>
<p>We also drop the <code>#![no_main]</code> attribute as it has no effect on library crates.</p>
<blockquote>
<p>There's an orthogonal question that arises at this stage: Should the <code>rt</code>
library provide a standard panicking behavior, or should it <em>not</em> provide a
<code>#[panic_handler]</code> function and leave the end user to choose the panicking
behavior? This document won't delve into that question and for simplicity will
leave the dummy <code>#[panic_handler]</code> function in the <code>rt</code> crate. However, we
wanted to inform the reader that there are other options.</p>
</blockquote>
<p>The second change involves providing the linker script we wrote before to the application crate. The linker will search for linker scripts in the library search path (<code>-L</code>) and in the directory
from which it's invoked. The application crate shouldn't need to carry around a copy of <code>link.x</code> so
we'll have the <code>rt</code> crate put the linker script in the library search path using a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a>.</p>
<pre><code class="language-console">$ # create a build.rs file in the root of `rt` with these contents
$ cat build.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::{env, error::Error, fs::File, io::Write, path::PathBuf};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // build directory for this crate
    let out_dir = PathBuf::from(env::var_os("OUT_DIR").unwrap());

    // extend the library search path
    println!("cargo:rustc-link-search={}", out_dir.display());

    // put `link.x` in the build directory
    File::create(out_dir.join("link.x"))?.write_all(include_bytes!("link.x"))?;

    Ok(())
}</code></pre></pre>
<p>Now the user can write an application that exposes the <code>main</code> symbol and link it to the <code>rt</code> crate.
The <code>rt</code> will take care of giving the program the right memory layout.</p>
<pre><code class="language-console">$ cd ..

$ cargo new --edition 2024 --bin app

$ cd app

$ # modify Cargo.toml to include the `rt` crate as a dependency
$ tail -n2 Cargo.toml
</code></pre>
<pre><code class="language-toml">[dependencies]
rt = { path = "../rt" }
</code></pre>
<pre><code class="language-console">$ # copy over the config file that sets a default target and tweaks the linker invocation
$ cp -r ../rt/.cargo .

$ # change the contents of `main.rs` to
$ cat src/main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

extern crate rt;

#[unsafe(no_mangle)]
pub fn main() -&gt; ! {
    let _x = 42;

    loop {}
}</code></pre></pre>
<p>The disassembly will be similar but will now include the user <code>main</code> function.</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -d --no-show-raw-insn
</code></pre>
<pre><code class="language-text">
app:	file format elf32-littlearm

Disassembly of section .text:

&lt;main&gt;:
               	push	{r7, lr}
               	mov	r7, sp
               	sub	sp, #0x4
               	movs	r0, #0x2a
               	str	r0, [sp]
               	b	0x14 &lt;main+0xc&gt;         @ imm = #-0x2
               	b	0x14 &lt;main+0xc&gt;         @ imm = #-0x4

&lt;Reset&gt;:
               	push	{r7, lr}
               	mov	r7, sp
               	bl	0x8 &lt;main&gt;              @ imm = #-0x16
</code></pre>
<h2 id="making-it-type-safe"><a class="header" href="#making-it-type-safe">Making it type safe</a></h2>
<p>The <code>main</code> interface works, but it's easy to get it wrong. For example, the user could write <code>main</code>
as a non-divergent function, and they would get no compile time error and undefined behavior (the
compiler will misoptimize the program).</p>
<p>We can add type safety by exposing a macro to the user instead of the symbol interface. In the
<code>rt</code> crate, we can write this macro:</p>
<pre><code class="language-console">$ tail -n12 ../rt/src/lib.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! entry {
    ($path:path) =&gt; {
        #[unsafe(export_name = "main")]
        pub unsafe fn __main() -&gt; ! {
            // type check the given path
            let f: fn() -&gt; ! = $path;

            f()
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Then the application writers can invoke it like this:</p>
<pre><code class="language-console">$ cat src/main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use rt::entry;

entry!(main);

fn main() -&gt; ! {
    let _x = 42;

    loop {}
}</code></pre></pre>
<p>Now the author will get an error if they change the signature of <code>main</code> to be
non divergent function, e.g. <code>fn()</code>.</p>
<h2 id="life-before-main"><a class="header" href="#life-before-main">Life before main</a></h2>
<p><code>rt</code> is looking good but it's not feature complete! Applications written against it can't use
<code>static</code> variables or string literals because <code>rt</code>'s linker script doesn't define the standard
<code>.bss</code>, <code>.data</code> and <code>.rodata</code> sections. Let's fix that!</p>
<p>The first step is to define these sections in the linker script:</p>
<pre><code class="language-console">$ # showing just a fragment of the file
$ sed -n 25,46p ../rt/link.x
</code></pre>
<pre><code class="language-text">  .text :
  {
    *(.text .text.*);
  } &gt; FLASH

  /* NEW! */
  .rodata :
  {
    *(.rodata .rodata.*);
  } &gt; FLASH

  .bss :
  {
    *(.bss .bss.*);
  } &gt; RAM

  .data :
  {
    *(.data .data.*);
  } &gt; RAM

  /DISCARD/ :
</code></pre>
<p>They just re-export the input sections and specify in which memory region each output section will
go.</p>
<p>With these changes, the following program will compile:</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use rt::entry;

entry!(main);

static RODATA: &amp;[u8] = b"Hello, world!";
static mut BSS: u8 = 0;
static mut DATA: u16 = 1;

#[allow(static_mut_refs)]
fn main() -&gt; ! {
    let _x = RODATA;
    let _y = unsafe { &amp;BSS };
    let _z = unsafe { &amp;DATA };

    loop {}
}</code></pre></pre>
<p>However if you run this program on real hardware and debug it, you'll observe that the <code>static</code>
variables <code>BSS</code> and <code>DATA</code> don't have the values <code>0</code> and <code>1</code> by the time <code>main</code> has been reached.
Instead, these variables will have junk values. The problem is that the contents of RAM are
random after powering up the device. You won't be able to observe this effect if you run the
program in QEMU.</p>
<p>As things stand if your program reads any <code>static</code> variable before performing a write to it then
your program has undefined behavior. Let's fix that by initializing all <code>static</code> variables before
calling <code>main</code>.</p>
<p>We'll need to tweak the linker script a bit more to do the RAM initialization:</p>
<pre><code class="language-console">$ # showing just a fragment of the file
$ sed -n 25,52p ../rt/link.x
</code></pre>
<pre><code class="language-text">  .text :
  {
    *(.text .text.*);
  } &gt; FLASH

  /* CHANGED! */
  .rodata :
  {
    *(.rodata .rodata.*);
  } &gt; FLASH

  .bss :
  {
    _sbss = .;
    *(.bss .bss.*);
    _ebss = .;
  } &gt; RAM

  .data : AT(ADDR(.rodata) + SIZEOF(.rodata))
  {
    _sdata = .;
    *(.data .data.*);
    _edata = .;
  } &gt; RAM

  _sidata = LOADADDR(.data);

  /DISCARD/ :
</code></pre>
<p>Let's go into the details of these changes:</p>
<pre><code class="language-text">    _sbss = .;
</code></pre>
<pre><code class="language-text">    _ebss = .;
</code></pre>
<pre><code class="language-text">    _sdata = .;
</code></pre>
<pre><code class="language-text">    _edata = .;
</code></pre>
<p>We associate symbols to the start and end addresses of the <code>.bss</code> and <code>.data</code> sections, which we'll
later use to initialize them.</p>
<pre><code class="language-text">  .data : AT(ADDR(.rodata) + SIZEOF(.rodata))
</code></pre>
<p>We set the Load Memory Address (LMA) of the <code>.data</code> section to the end of the <code>.rodata</code>
section. The <code>.data</code> contains <code>static</code> variables with a non-zero initial value; the Virtual Memory
Address (VMA) of the <code>.data</code> section is somewhere in RAM -- this is where the <code>static</code> variables are
located. The initial values of those <code>static</code> variables, however, must be allocated in non volatile
memory (Flash); the LMA is where in Flash those initial values are stored.</p>
<pre><code class="language-text">  _sidata = LOADADDR(.data);
</code></pre>
<p>Finally, we associate a symbol to the LMA of <code>.data</code>.</p>
<p>Using our initialization code, we zero the <code>.bss</code> section and initialize the <code>.data</code> section. We can reference
the symbols we created in the linker script from the code. The <em>addresses</em><sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> of these symbols are
the boundaries of the <code>.bss</code> and <code>.data</code> sections.</p>
<p>We could write the initialization <code>.bss</code> and <code>.data</code> section code in pure Rust code. In fact, earlier
versions of this book did so. However, several soundness questions have been raised over time,
and it is no longer considered good practice to initialize them in Rust code. See the
<a href="./sections-in-rust.html">Why don't we initialize .data and .bss using Rust</a> section of the book for more details.
We will write the initialization code using the <code>global_asm!</code> macro to define our reset handler.</p>
<p>The updated reset handler, now written in <code>Thumb-2</code> assembly, is shown below:</p>
<pre><code class="language-console">$ head -n53 ../rt/src/lib.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

use core::arch::global_asm;

global_asm!(
    ".text

     .syntax unified
     .global _sbss
     .global _ebss

     .global _sdata
     .global _edata
     .global _sidata

     .global main
     .global Reset

     .type Reset,%function
     .thumb_func
     Reset:

     _init_bss:
         movs r2, #0
         ldr r0, =_sbss
         ldr r1, =_ebss

     1:
         cmp r1, r0
         beq _init_data
         strb r2, [r0]
         add r0, #1
         b 1b

     _init_data:
         ldr r0, =_sdata
         ldr r1, =_edata
         ldr r2, =_sidata

     1:
         cmp r0, r1
         beq _main_trampoline
         ldrb r3, [r2]
         strb r3, [r0]
         add r0, #1
         add r2, #1
         b 1b
     _main_trampoline:
         ldr r0, =main
         bx r0"
);
<span class="boring">}</span></code></pre></pre>
<p>Now end users can directly and indirectly make use of <code>static</code> variables without running into
undefined behavior!</p>
<blockquote>
<p>In the code above we performed the memory initialization in a bytewise fashion. It's possible to
force the <code>.bss</code> and <code>.data</code> sections to be aligned to, say, 4 bytes. This fact can then be used
in the Rust code to perform the initialization wordwise while omitting alignment checks. If you
are interested in learning how this can be achieved check the <a href="https://github.com/japaric/cortex-m-rt/tree/v0.5.1"><code>cortex-m-rt</code></a> crate.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>The fact that the addresses of the linker script symbols must be used here can be confusing and
unintuitive. An elaborate explanation for this oddity can be found <a href="https://stackoverflow.com/a/40392131">here</a>. <a href="#fr-1-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="memory-layout.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="sections-in-rust.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="memory-layout.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="sections-in-rust.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
